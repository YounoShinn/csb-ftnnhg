{"mappings":"IC4IqB,EAnErB,QAAQ,GAAA,CAAU,aAClB,QAAQ,GAAA,CAAY,cAMpB,QAAQ,GAAA,CAAU,QAMlB,QAAQ,GAAA,CAHC,IAcR,MAAM,EAAY,CAChB,KAAO,QACP,IAAM,EACR,EAEM,EAAW,CAAC,KAAK,EAAE,EAAU,IAAA,CAAK,KAAK,EAAE,EAAU,GAAA,CAAI,IAAI,CAAC,CAClE,QAAQ,GAAA,CAAI,GAEZ,KAAM,CAAA,KAAC,CAAI,CAAA,IAAG,CAAG,CAAC,CAAG,EACf,EAAW,CAAC,KAAK,EAAE,EAAK,KAAK,EAAE,EAAI,KAAK,CAAC,CAC/C,QAAQ,GAAA,CAAI,GAMZ,KAAM,CAAC,EAAM,EAAK,CAFC,CAAC,QAAQ,GAAG,CAGzB,EAAW,CAAC,EAAE,EAAE,EAAM,EAAE,EAAE,EAAK,SAAS,CAAC,CAChD,QAAQ,GAAA,CAAI,GAUX,AADgB,CAAA,CAAC,EAAO,KAAK,GAAK,QAAQ,GAAA,CAAI,CAAC,KAAK,EAAE,EAAK,EAAE,CAAC,CAAA,IAY/D,MAAM,EAAQ,CAAC,EAAE,EAAE,CACnB,QAAQ,GAAA,CAAI,GACZ,QAAQ,GAAA,IAAO,GAEe,QAAQ,GAAA,CAAI,AAE7B,EAFkC,GAM/C,KAAM,CAAC,EAAK,EAAK,GAAG,EAAK,CADb,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAEvB,QAAQ,GAAA,CAAI,GACZ,QAAQ,GAAA,CAAI,GACZ,QAAQ,GAAA,CAAI,GAGZ,MAAM,EAAM,CAAC,GAAG,GAAG,CAGb,EAAM,IAAI,EAAK,CACrB,QAAQ,GAAA,CAAI,GACZ,MAAM,EAAM,IAAI,EAJH,GAAG,GAIa,CAC7B,QAAQ,GAAA,CAAI,GAIZ,QAAQ,GAAA,CADK,GAWb,MAAM,EAAS,CAAC,IAAI,QAAQ,MAAM,CAClC,IAAI,IAAI,EAAM,EAAG,EAAM,EAAQ,MAAA,CAAQ,IACrC,QAAQ,GAAA,CAAI,CAAO,CAAC,EAAM,EAG5B,MAAM,EAAW,EAAQ,GAAA,CAAI,AAAC,GACrB,GAIT,QAAQ,GAAA,CAAI,GAGZ,EAAQ,GAAA,CAAI,AAAC,GAAS,QAAQ,GAAA,CAAI,IAMlC,IAAI,IAAI,EAAM,EAAG,EAAM,EAAQ,MAAA,CAAQ,IACrC,QAAQ,GAAA,CAAI,CAAC,EAAE,EAAM,EAAE,IAAI,EAAE,CAAO,CAAC,EAAM,CAAC,EAAE,CAAC,EAGjD,EAAQ,GAAA,CAAI,CAAC,EAAK,IAAU,QAAQ,GAAA,CAAI,CAAC,EAAE,EAAM,GAAG,EAAE,EAAK,EAAE,CAAC,GAI9D,MAAM,EAAW,EAAQ,GAAA,CAAI,AAAC,GAC5B,AAAG,AAAS,UAAT,EACM,EAEA,CAAC,EAAE,EAAK,EAAE,CAAC,EAGtB,QAAQ,GAAA,CAAI,GAMZ,MAAM,EAAU,AADD,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CACF,MAAA,CAAO,AAAC,GACvB,EAAO,GAAI,GAEpB,QAAQ,GAAA,CAAI,GAUZ,QAAQ,GAAA,CADa,UAGrB,MAAM,EAAO,OACP,EAAe,AAAgB,UAAhB,OAAO,EAAoB,EAAK,cAAA,GAAmB,aACxE,QAAQ,GAAA,CAAI,GAMZ,QAAQ,GAAA,CAFgC,aAiBrC,QAAQ,GAAA,CAAI,eAGZ,QAAQ,GAAA,CAAI,cAMf,QAAQ,GAAA,CADW,SAKnB,QAAQ,GAAA,CAFK,KASb,QAAQ,GAAA,CADW","sources":["<anon>","src/index.mjs"],"sourcesContent":["var $761f97bf09d51d3e$exports = {};\n/**\n * const letの宣言\n */ // var val1 = \"var変数\";\n// console.log(val1);\n// //var変数は上書き可能//\n// val1 = \"var変数を変更したった\";\n// console.log(val1);\n// //上書きではなくて再宣言も可能//\n// var val1 =\"varを再宣言\";\n// console.log(val1);\n// \n// const val3 = \"const変数\";\n// console.log(val3);\n// //const変数は上書き不可\n//val3 = \"constを上書き\";\n// //constは再宣言は出来ない。\n// const val3 = \"constを再宣言\";\n// const val4 = {\n//   name: \"ようのしん\",\n//   age: 30,\n// };\n// //constでもオブジェクトの中身(プロパティ)は変更や追加が可能\n// val4.name = \"younoshinn\";\n// val4.address = \"奈良県\";\n// console.log(val4);\n//constでも配列の中身は変更や追加が可能\n// const val5 = ['dog','cat'];\n// val5[0] =\"bird\";\n// val5.push(\"ちんちん\");　　→　配列の中身に追加する際にはpushを使う。\n// console.log(val5);\n//   //テンプレート文字列\n// const name = \"ようのしん\";\n// const age = \"30\";\n// //私の名前はようのしんで、年齢は３０歳です。　　を表すには\n// //従来の方法\n// const message1 = \"私の名前は\" + name + \"で、年齢は\" + age + \"際です。\";\n// console.log(message1);\n// //テンプレート文字列を用いた方法\n// const message2 = `私の名前は${name}で、年齢は${age}です。`;\n// console.log(message2);\n/**\n * アロー関数\n */ //従来の関数の作り方\nfunction $761f97bf09d51d3e$var$funk1(str) {\n    return str;\n}\n//もしくは\nconst $761f97bf09d51d3e$var$funk1_1 = function(str) {\n    return str;\n};\nconsole.log($761f97bf09d51d3e$var$funk1(\"funk1ですよ！\"));\nconsole.log($761f97bf09d51d3e$var$funk1_1(\"funk1_1ですよ\"));\n//アロー関数\nconst $761f97bf09d51d3e$var$funk2 = (str2)=>{\n    return str2; //処理が単一の式で終わるような式の場合は、{}もreturnも省略できる。\n};\nconsole.log($761f97bf09d51d3e$var$funk2(\"おっぱい\"));\nconst $761f97bf09d51d3e$var$funk3 = (num1, num2)=>{\n    return num1 + num2;\n};\n//次のように省略もできる　const funk3 = (num1,num2) => num1+num2;\nconsole.log($761f97bf09d51d3e$var$funk3(10, 20));\n/**\n * 分割代入について\n */ const $761f97bf09d51d3e$var$myprofile = {\n    name: \"ようのしん\",\n    age: 30\n};\nconst $761f97bf09d51d3e$var$message3 = `私の名前は${$761f97bf09d51d3e$var$myprofile.name}で、年齢は${$761f97bf09d51d3e$var$myprofile.age}歳です！`;\nconsole.log($761f97bf09d51d3e$var$message3); //毎回myprofileと入力するのはだるいよね？\nconst { name: $761f97bf09d51d3e$var$name, age: $761f97bf09d51d3e$var$age } = $761f97bf09d51d3e$var$myprofile;\nconst $761f97bf09d51d3e$var$message4 = `私の名前は${$761f97bf09d51d3e$var$name}で、年齢は${$761f97bf09d51d3e$var$age}歳ですか？`;\nconsole.log($761f97bf09d51d3e$var$message4);\n//↑ あらかじめ先に値を取り出すことで、連想配列（オブジェクト）の名前を省略する事ができる。\n//↓ 配列でも似たような形で使える\nconst $761f97bf09d51d3e$var$myprofile2 = [\n    \"ようのしん\",\n    30\n];\nconst [$761f97bf09d51d3e$var$name2, $761f97bf09d51d3e$var$age2] = $761f97bf09d51d3e$var$myprofile2;\nconst $761f97bf09d51d3e$var$message5 = `私は${$761f97bf09d51d3e$var$name2}で、${$761f97bf09d51d3e$var$age2}になってしまった。`;\nconsole.log($761f97bf09d51d3e$var$message5);\n/**\n * デフォルト値　について\n */ const $761f97bf09d51d3e$var$sayhello = (name = \"ゲスト\")=>console.log(`よく来たな${name}さん`);\n$761f97bf09d51d3e$var$sayhello();\n//neme = \"\"は、nameに入力がなかった場合のデフォルト値となる。\n/**\n * スプレッド構文について...\n */ //配列の展開\nconst $761f97bf09d51d3e$var$array1 = [\n    1,\n    2\n];\nconsole.log($761f97bf09d51d3e$var$array1); //これだとコンソールに[1,2]とそのまま表示される。\nconsole.log(...$761f97bf09d51d3e$var$array1); //こうすることで、[]をなくし、実際の中身を展開してくれる。\n//実用的なつかい方↓\nconst $761f97bf09d51d3e$var$sumfunk = (num1, num2)=>console.log(num1 + num2);\n//sumfunk(array1[0],array1[1]);  //これで合計は3となる\n$761f97bf09d51d3e$var$sumfunk(...$761f97bf09d51d3e$var$array1); //この書き方でも1つ上の行と同じ結果となる。\n//まとめる\nconst $761f97bf09d51d3e$var$arr2 = [\n    1,\n    2,\n    3,\n    4,\n    5\n];\nconst [$761f97bf09d51d3e$var$num3, $761f97bf09d51d3e$var$num4, ...$761f97bf09d51d3e$var$arr3] = $761f97bf09d51d3e$var$arr2; // →　これは分割代入　　3,4,5をまとめて代入している。\nconsole.log($761f97bf09d51d3e$var$num3);\nconsole.log($761f97bf09d51d3e$var$num4);\nconsole.log($761f97bf09d51d3e$var$arr3);\n//コピーと結合\nconst $761f97bf09d51d3e$var$arr4 = [\n    10,\n    20\n];\nconst $761f97bf09d51d3e$var$arr5 = [\n    30,\n    40\n];\nconst $761f97bf09d51d3e$var$arr6 = [\n    ...$761f97bf09d51d3e$var$arr4\n]; //これでarr4と全く同じ配列のarr6が完成。（コピー）\nconsole.log($761f97bf09d51d3e$var$arr6);\nconst $761f97bf09d51d3e$var$arr7 = [\n    ...$761f97bf09d51d3e$var$arr4,\n    ...$761f97bf09d51d3e$var$arr5\n]; //arr4とarr5を結合した形。\nconsole.log($761f97bf09d51d3e$var$arr7);\n//コピーについての補足。\nconst $761f97bf09d51d3e$var$arr8 = $761f97bf09d51d3e$var$arr4;\nconsole.log($761f97bf09d51d3e$var$arr8); //このコピーでも一応arr4のコピーは作れるが、問題あり。\n//例えば、arr8の値を、　arr8[0]=100 のように　後から数字を変更すると、arr4の1つめも変更されてしまう。\n/**\n * mapやフィルターを使った配列の処理。\n */ //map\nconst $761f97bf09d51d3e$var$namearr = [\n    \"森\",\n    \"ようのしん\",\n    \"よちゅ\"\n];\nfor(let index = 0; index < $761f97bf09d51d3e$var$namearr.length; index++)console.log($761f97bf09d51d3e$var$namearr[index]);\nconst $761f97bf09d51d3e$var$namearr2 = $761f97bf09d51d3e$var$namearr.map((name)=>{\n    return name;\n});\n//mapは、すでにある配列に対して使える関数で、中にアロー関数を書き、\n//引数を設定することで、その引数に順番に値が渡されるというもの。\nconsole.log($761f97bf09d51d3e$var$namearr2);\n//実際の使い方↓\n$761f97bf09d51d3e$var$namearr.map((name)=>console.log(name));\n//namearr.map((name) => {return console.log(name)})の省略形。\n//たったこれだけの量で、for構文の代用ができる。\n//〜番目は〜ですの形で出力したい場合下記のような形となる。\nfor(let index = 0; index < $761f97bf09d51d3e$var$namearr.length; index++)console.log(`${index + 1}番目は、${$761f97bf09d51d3e$var$namearr[index]}です`);\n//↓これをmapを使って表すと\n$761f97bf09d51d3e$var$namearr.map((name, index)=>console.log(`${index}番目は${name}です`));\n//mapは、1つ目の引数には\"中身\"が、２つめの引数には\"順番\"が入ってくる。\n//実践的な例文↓  自分の名前以外には”さん”をつける\nconst $761f97bf09d51d3e$var$namearr3 = $761f97bf09d51d3e$var$namearr.map((name)=>{\n    if (name === \"ようのしん\") return name;\n    else return `${name}さん`;\n});\nconsole.log($761f97bf09d51d3e$var$namearr3);\n//filter\nconst $761f97bf09d51d3e$var$numarr1 = [\n    1,\n    2,\n    3,\n    4,\n    5\n];\nconst $761f97bf09d51d3e$var$numarr2 = $761f97bf09d51d3e$var$numarr1.filter((num5)=>{\n    return num5 % 2 === 1;\n});\nconsole.log($761f97bf09d51d3e$var$numarr2);\n//使い方は基本的にmapと同じ書き方。\n//絞るとができる。\n/**\n * 三項演算子\n */ const $761f97bf09d51d3e$var$val1 = \"trueです\";\nconsole.log($761f97bf09d51d3e$var$val1);\nconst $761f97bf09d51d3e$var$num7 = \"1300\";\nconst $761f97bf09d51d3e$var$formattednum = typeof $761f97bf09d51d3e$var$num7 === \"number\" ? $761f97bf09d51d3e$var$num7.toLocaleString() : \"数字を入力して下さい\";\nconsole.log($761f97bf09d51d3e$var$formattednum);\n//tolocalestring()は、数字の場合だけ、3桁でかんまを入れてくれる関数。\nconst $761f97bf09d51d3e$var$checkSum = (num8, num9)=>{\n    return num8 + num9 < 100 ? num8 + num9 : \"許容範囲超えてる！\";\n};\nconsole.log($761f97bf09d51d3e$var$checkSum(30, 500));\n/**\n * 論理演算子の本当の意味　&&  ||\n */ const $761f97bf09d51d3e$var$base1 = true;\nconst $761f97bf09d51d3e$var$base2 = true;\nif ($761f97bf09d51d3e$var$base1 || $761f97bf09d51d3e$var$base2) console.log(\"どちらかはtrueです\");\nif ($761f97bf09d51d3e$var$base1 && $761f97bf09d51d3e$var$base2) console.log(\"両方ともtrueです\");\n// 上記の記載から考えると、||は、”または”という意味合いに思える。しかし、、、\nconst $761f97bf09d51d3e$var$buy = null;\nconst $761f97bf09d51d3e$var$pay = $761f97bf09d51d3e$var$buy || \"金額未設定\";\nconsole.log($761f97bf09d51d3e$var$pay);\n// この結果は金額未設定と表示される。\nconst $761f97bf09d51d3e$var$buy2 = 1000;\nconst $761f97bf09d51d3e$var$pay2 = $761f97bf09d51d3e$var$buy2 || \"金額未設定\";\nconsole.log($761f97bf09d51d3e$var$pay2);\n// この結果は1000と表示される。\n// 何故なら、 ｜｜ の本当の意味は、　「｜｜の左側がfalseだった場合、右側を返す」という意味だから。\nconst $761f97bf09d51d3e$var$buy3 = 1000;\nconst $761f97bf09d51d3e$var$pay3 = $761f97bf09d51d3e$var$buy2 && \"何か設定されています\";\nconsole.log($761f97bf09d51d3e$var$pay3); // 逆に、$$は、左側がtrueの場合、右側を返すという意味である。\n\n\n//# sourceMappingURL=index.52555c82.js.map\n","/**\n * const letの宣言\n */\n// var val1 = \"var変数\";\n// console.log(val1);\n\n// //var変数は上書き可能//\n\n// val1 = \"var変数を変更したった\";\n// console.log(val1);\n\n// //上書きではなくて再宣言も可能//\n// var val1 =\"varを再宣言\";\n// console.log(val1);\n\n// \n\n// const val3 = \"const変数\";\n// console.log(val3);\n\n// //const変数は上書き不可\n  //val3 = \"constを上書き\";\n\n// //constは再宣言は出来ない。\n  // const val3 = \"constを再宣言\";\n\n  // const val4 = {\n  //   name: \"ようのしん\",\n  //   age: 30,\n  // };\n  // //constでもオブジェクトの中身(プロパティ)は変更や追加が可能\n  // val4.name = \"younoshinn\";\n  // val4.address = \"奈良県\";\n  // console.log(val4);\n\n\n  //constでも配列の中身は変更や追加が可能\n  // const val5 = ['dog','cat'];\n  // val5[0] =\"bird\";\n  // val5.push(\"ちんちん\");　　→　配列の中身に追加する際にはpushを使う。\n  // console.log(val5);\n\n\n//   //テンプレート文字列\n// const name = \"ようのしん\";\n// const age = \"30\";\n// //私の名前はようのしんで、年齢は３０歳です。　　を表すには\n\n// //従来の方法\n// const message1 = \"私の名前は\" + name + \"で、年齢は\" + age + \"際です。\";\n// console.log(message1);\n\n// //テンプレート文字列を用いた方法\n// const message2 = `私の名前は${name}で、年齢は${age}です。`;\n// console.log(message2);\n\n\n\n\n\n/**\n * アロー関数\n */\n\n //従来の関数の作り方\n function funk1(str){\n   return str;\n }\n//もしくは\nconst funk1_1 = function(str){\n  return str;\n}\n\nconsole.log(funk1(\"funk1ですよ！\"));\nconsole.log(funk1_1(\"funk1_1ですよ\"));\n\n//アロー関数\nconst funk2 = (str2) => {  //()は省略してもいい。\n  return str2; //処理が単一の式で終わるような式の場合は、{}もreturnも省略できる。\n}\nconsole.log(funk2(\"おっぱい\"));\n\nconst funk3 =(num1,num2) => {\n  return num1 + num2 ;\n}\n//次のように省略もできる　const funk3 = (num1,num2) => num1+num2;\nconsole.log(funk3(10,20));\n\n\n\n\n\n\n/**\n * 分割代入について\n */\n\n const myprofile = {\n   name : \"ようのしん\",\n   age : 30,\n };\n\n const message3 = `私の名前は${myprofile.name}で、年齢は${myprofile.age}歳です！`;\n console.log(message3);  //毎回myprofileと入力するのはだるいよね？\n\n const {name , age} = myprofile;\n const message4 = `私の名前は${name}で、年齢は${age}歳ですか？`;\n console.log(message4);\n //↑ あらかじめ先に値を取り出すことで、連想配列（オブジェクト）の名前を省略する事ができる。\n \n //↓ 配列でも似たような形で使える\n const myprofile2 = [\"ようのしん\",30];\n\n const [name2,age2] = myprofile2;\n const message5 = `私は${name2}で、${age2}になってしまった。`;\nconsole.log(message5);\n\n\n\n\n/**\n * デフォルト値　について\n */\n\n const sayhello =(name = \"ゲスト\") => console.log(`よく来たな${name}さん`);\n sayhello();\n //neme = \"\"は、nameに入力がなかった場合のデフォルト値となる。\n\n\n\n\n\n/**\n * スプレッド構文について...\n */\n //配列の展開\nconst array1 =[1,2];\nconsole.log(array1); //これだとコンソールに[1,2]とそのまま表示される。\nconsole.log(...array1); //こうすることで、[]をなくし、実際の中身を展開してくれる。\n//実用的なつかい方↓\nconst sumfunk =(num1,num2) => console.log(num1+num2);\n//sumfunk(array1[0],array1[1]);  //これで合計は3となる\n  sumfunk(...array1);       //この書き方でも1つ上の行と同じ結果となる。\n\n//まとめる\nconst arr2 =[1,2,3,4,5];\nconst [num3,num4,...arr3] = arr2; // →　これは分割代入　　3,4,5をまとめて代入している。\nconsole.log(num3);\nconsole.log(num4);\nconsole.log(arr3);\n\n//コピーと結合\nconst arr4 =[10,20];\nconst arr5 =[30,40];\n\nconst arr6 =[...arr4]; //これでarr4と全く同じ配列のarr6が完成。（コピー）\nconsole.log(arr6);\nconst arr7 =[...arr4,...arr5]; //arr4とarr5を結合した形。\nconsole.log(arr7);\n\n//コピーについての補足。\nconst arr8 = arr4;\nconsole.log(arr8); //このコピーでも一応arr4のコピーは作れるが、問題あり。\n//例えば、arr8の値を、　arr8[0]=100 のように　後から数字を変更すると、arr4の1つめも変更されてしまう。\n\n\n\n\n/**\n * mapやフィルターを使った配列の処理。\n */\n//map\nconst namearr =[\"森\",\"ようのしん\",\"よちゅ\"];\nfor(let index=0;　index<namearr.length; index++){\n  console.log(namearr[index]);\n}\n\nconst namearr2 = namearr.map((name) => {\n  return name;\n})\n//mapは、すでにある配列に対して使える関数で、中にアロー関数を書き、\n//引数を設定することで、その引数に順番に値が渡されるというもの。\nconsole.log(namearr2);\n\n//実際の使い方↓\nnamearr.map((name) => console.log(name));\n//namearr.map((name) => {return console.log(name)})の省略形。\n//たったこれだけの量で、for構文の代用ができる。\n\n\n//〜番目は〜ですの形で出力したい場合下記のような形となる。\nfor(let index=0;　index<namearr.length; index++){\n  console.log(`${index+1}番目は、${namearr[index]}です`);\n}\n //↓これをmapを使って表すと\nnamearr.map((name,index) => console.log(`${index}番目は${name}です`));\n//mapは、1つ目の引数には\"中身\"が、２つめの引数には\"順番\"が入ってくる。\n\n//実践的な例文↓  自分の名前以外には”さん”をつける\nconst namearr3 = namearr.map((name) => {\n  if(name === \"ようのしん\"){\n    return name\n  } else {\n    return `${name}さん`\n  }\n});\nconsole.log(namearr3);\n\n\n\n//filter\nconst numarr1 =[1,2,3,4,5];\nconst numarr2 = numarr1.filter((num5) => {\n  return num5 % 2===1;\n})\nconsole.log(numarr2);\n//使い方は基本的にmapと同じ書き方。\n//絞るとができる。\n\n\n\n/**\n * 三項演算子\n */\nconst val1 = 1 > 0 ? \"trueです\" : \"faoulsです\";\nconsole.log(val1);\n\nconst num7 = \"1300\";\nconst formattednum = typeof num7 === 'number' ? num7.toLocaleString() : \"数字を入力して下さい\";\nconsole.log(formattednum); \n//tolocalestring()は、数字の場合だけ、3桁でかんまを入れてくれる関数。\n\nconst checkSum = (num8,num9) => {\n  return num8 + num9 <100 ? num8+num9 : \"許容範囲超えてる！\";\n}\nconsole.log(checkSum(30,500));\n\n\n\n\n\n/**\n * 論理演算子の本当の意味　&&  ||\n */\n\n\n const base1 =true;\n const base2 =true;\n\n if(base1 || base2){\n   console.log(\"どちらかはtrueです\");\n }\n if(base1 && base2){\n   console.log(\"両方ともtrueです\");\n }\n// 上記の記載から考えると、||は、”または”という意味合いに思える。しかし、、、\n\nconst buy = null;\nconst pay = buy || \"金額未設定\";\nconsole.log(pay);  \n// この結果は金額未設定と表示される。\nconst buy2 = 1000;\nconst pay2 = buy2 || \"金額未設定\";\nconsole.log(pay2);  \n// この結果は1000と表示される。\n// 何故なら、 ｜｜ の本当の意味は、　「｜｜の左側がfalseだった場合、右側を返す」という意味だから。\n\n\nconst buy3 =1000\nconst pay3=buy2 && \"何か設定されています\"\nconsole.log(pay3);\n// 逆に、$$は、左側がtrueの場合、右側を返すという意味である。"],"names":["num2","console","log","num1","$761f97bf09d51d3e$var$myprofile","name","age","$761f97bf09d51d3e$var$message3","$761f97bf09d51d3e$var$name","$761f97bf09d51d3e$var$age","$761f97bf09d51d3e$var$message4","$761f97bf09d51d3e$var$name2","$761f97bf09d51d3e$var$age2","$761f97bf09d51d3e$var$message5","$761f97bf09d51d3e$var$sayhello","$761f97bf09d51d3e$var$array1","$761f97bf09d51d3e$var$num3","$761f97bf09d51d3e$var$num4","$761f97bf09d51d3e$var$arr3","$761f97bf09d51d3e$var$arr4","$761f97bf09d51d3e$var$arr6","$761f97bf09d51d3e$var$arr7","$761f97bf09d51d3e$var$namearr","index","length","$761f97bf09d51d3e$var$namearr2","map","$761f97bf09d51d3e$var$namearr3","$761f97bf09d51d3e$var$numarr2","$761f97bf09d51d3e$var$numarr1","filter","num5","$761f97bf09d51d3e$var$num7","$761f97bf09d51d3e$var$formattednum","toLocaleString"],"version":3,"file":"index.52555c82.js.map"}